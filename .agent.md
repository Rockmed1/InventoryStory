# Agent Context & Project Memory

## Inventory Story - Smart Inventory Management Platform

---

## **PROJECT OVERVIEW**

### **Application Type**

- **Multi-tenant SaaS** inventory management system
- **Target Users**: Small businesses (<1000 items) selling on multiple platforms (eBay, Facebook Marketplace, Craigslist)
- **Business Model**: Personal use → SaaS expansion

### **Technology Stack**

- **Frontend**: Next.js 15.4.3, React 19, Tailwind CSS, Radix UI
- **Backend**: PostgreSQL with Supabase, Next.js API routes
- **Authentication**: Clerk (in migration from hardcoded auth)
- **State Management**: React Query + Zustand
- **Validation**: Zod schemas

---

## **ARCHITECTURE PATTERNS & CONVENTIONS**

### **Database Interaction Pattern**

- **ALL database interactions use RPC calls** to PostgreSQL functions
- **No direct SQL queries** in application code
- **Pattern**: `supabase.rpc("function_name", { _data: payload })`
- **Example**: `await supabase.rpc("fn_get_items", { _data: { _item_id: null, _usr_uuid, _org_uuid } })`

### **PostgreSQL Function Conventions**

- **Naming**: `fn_[action]_[entity]` (public) or `_fn_[action]_[entity]` (private/utility)
- **Parameters**: Always accept `_data JSONB` parameter
- **Security**: All functions use `SECURITY DEFINER` and `SET search_path = utils`
- **Error Handling**: Comprehensive exception handling with meaningful messages
- **Context Setting**: Use `utils._fn_set_app_context()` for user/org validation and RLS

### **Multi-Tenant Data Isolation**

- **Row-Level Security (RLS)** enabled on all tables
- **Organization-scoped operations** via `_fn_set_app_context()`
- **User-org membership validation** in every function
- **Cache keys include org context**: `item-${org_uuid}-${item_id}`

### **Authentication Architecture**

- **Current**: Hardcoded UUIDs (temporary)
- **Target**: Clerk authentication with direct Clerk ID usage
- **Strategy**: JIT sync with future webhook integration
- **Org Switching**: Redirect-based approach (approved decision)

---

## **DATABASE SCHEMA OVERVIEW**

### **Core Schemas**

```sql
usrs.usr (usr_id, usr_uuid, clerk_user_id, usr_name, first_name, last_name, email)
orgs.org (org_id, org_uuid, clerk_org_id, org_name, org_desc)
usrs.usr_org (usr_id, org_id, active, role) -- Many-to-many relationship
items.item (item_id, item_name, item_desc, item_class_id, org_id)
locations.location (loc_id, loc_name, org_id)
locations.bin (bin_id, bin_name, loc_id, org_id)
trans.item_trx (item_trx_id, trx_type_id, trx_date, org_id)
trans.item_trx_detail (item_trx_detail_id, item_trx_id, item_id, from_bin_id, to_bin_id, qty_in, qty_out)
```

### **Key Relationships**

- Users belong to multiple organizations (many-to-many)
- All business data is org-scoped (items, locations, transactions)
- Transactions have header-detail structure
- Items are tracked by location/bin with quantity on hand (QOH)

### **Conventions**

- All db functions start with fn
- db function starting with \_fn are for db use only while external facing(or shared) functions start with fn
- db views start with v\_
- inside a db function all input params or declare variables start with \_
-

## **EXISTING POSTGRESQL FUNCTIONS**

### **User/Organization Management Functions**

```sql
-- Core utility functions (EXISTING - WORKING)
utils._fn_get_usr_id(_usr_uuid UUID) → INTEGER
utils._fn_get_org_id(_org_uuid UUID) → INTEGER
utils._fn_assert_usr_org_auth(_usr_id INTEGER, _org_id INTEGER) → VOID
utils._fn_set_app_context(_data JSONB, _keys_param TEXT[], _fn_name TEXT, _option TEXT) → TABLE

-- User management (EXISTING - WORKING)
utils.fn_create_usr(_data JSONB) → JSON
utils.fn_get_usr_uuid(_usr_name VARCHAR) → UUID
utils.fn_get_usr_orgs(_usr_uuid UUID) → JSON

-- Organization management (EXISTING - WORKING)
utils.fn_create_organization(_data JSONB) → JSON
utils._fn_assign_usr_org(_usr_id INTEGER, _org_id INTEGER) → BOOLEAN
```

### **CLERK INTEGRATION REQUIREMENTS**

#### **Functions Needed for Clerk Migration**

```sql
-- NEW: Get user/org data by Clerk IDs (consolidated single call)
utils.fn_get_user_org_by_clerk_ids(_clerk_user_id VARCHAR, _clerk_org_id VARCHAR) → JSONB

-- NEW: JIT sync function (atomic user/org/membership creation)
utils.fn_ensure_user_org_exists(_clerk_usr_data JSONB, _clerk_org_data JSONB) → JSONB

-- MODIFY: Update _fn_set_app_context to accept Clerk IDs
utils._fn_set_app_context(_data JSONB) -- Now accepts clerk_user_id/clerk_org_id instead of UUIDs
```

#### **Pattern for New Functions**

```sql
-- Follow existing pattern:
CREATE OR REPLACE FUNCTION utils.fn_get_user_org_by_clerk_ids(
  _clerk_user_id VARCHAR(50),
  _clerk_org_id VARCHAR(50)
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = utils
AS $$
DECLARE
  _result JSONB;
BEGIN
  -- Implementation following existing patterns
  -- Return consolidated user/org/membership data
END;
$$;

ALTER FUNCTION utils.fn_get_user_org_by_clerk_ids OWNER TO utils_admin;
```

---

## **CACHING STRATEGY**

### **Triple-Layer Caching**

1. **Next.js Cache (Server)**: `unstable_cache()` with org-scoped keys
2. **React Query (Client)**: Org-isolated QueryClient instances
3. **PostgreSQL**: Function result caching where appropriate

### **Cache Key Patterns**

- **Server**: `entity-${org_uuid}-${entity_id}`
- **Client**: `["entity", { id: "entity_id" }]` (org isolation via separate QueryClients)
- **Tags**: Same as keys for invalidation

### **Org Isolation Strategy**

- **Server**: Org context in cache keys and database functions
- **Client**: Separate QueryClient instances per organization
- **Switching**: Clear caches and redirect to home page

---

## **DATA FLOW PATTERNS**

### **Server Component Data Flow**

```
Server Component → getQueryClient() → prefetchQuery() → getServerData() →
createDataService() → getItems() → supabase.rpc("fn_get_items") →
PostgreSQL function → RLS-filtered results
```

### **Client Component Data Flow**

```
Client Component → useQueryClient() (org-specific) → useSuspenseQuery() →
useApiData() → fetch("/api/v1/entities/item") → API route →
createDataService() → supabase.rpc() → PostgreSQL function
```

### **Form Submission Flow**

```
Form → Server Action → createDataService() → supabase.rpc("fn_create_item") →
PostgreSQL function → revalidateTag() → Client cache invalidation
```

---

## **CURRENT DECISIONS & STATUS**

### **Authentication Migration**

- **Status**: In progress - migrating from hardcoded to Clerk
- **Approach**: Parameter injection for QueryClient (`getQueryClient(orgId)`)
- **Data Sync**: JIT sync with future webhook integration
- **Org Switching**: Redirect-based (approved)

### **Key Implementation Decisions**

1. **Use Clerk IDs directly** in database calls (no UUID mapping layer)
2. **Consolidate related database operations** into single functions
3. **Maintain existing RPC pattern** and PostgreSQL function conventions
4. **Keep org isolation** via separate QueryClient instances

---

## **DEVELOPMENT PATTERNS**

### **Adding New Entities**

1. Create database table with org_id and RLS
2. Create PostgreSQL functions following naming conventions
3. Add to entityConfig for client-side configuration
4. Create React components following existing patterns
5. Add to navigation and routing

### **Database Function Development**

1. Follow existing naming: `fn_[action]_[entity]` or `_fn_[action]_[entity]`
2. Use `_data JSONB` parameter pattern
3. Include comprehensive error handling
4. Set proper ownership and security
5. Test with sample data

### **Client Component Patterns**

1. Use `useAuth()` for authentication context
2. Use `useSuspenseQuery()` for data fetching
3. Use `useMutation()` for data modifications
4. Follow form patterns with react-hook-form + Zod
5. Implement optimistic updates where appropriate

---

## **TESTING & VALIDATION**

### **Database Function Testing**

```sql
-- Test pattern for new functions
SELECT fn_get_user_org_by_clerk_ids('user_test123', 'org_test123');
SELECT fn_ensure_user_org_exists(
  '{"id": "user_test", "first_name": "Test", "last_name": "User"}'::jsonb,
  '{"id": "org_test", "name": "Test Org"}'::jsonb
);
```

### **Integration Testing Checklist**

- [ ] User authentication and org selection
- [ ] Database function execution with proper context
- [ ] RLS enforcement and data isolation
- [ ] Cache invalidation and updates
- [ ] Error handling and edge cases

---

## **COMMON ISSUES & SOLUTIONS**

### **Server/Client Hook Conflicts**

- **Issue**: React hooks in universal files
- **Solution**: Environment-specific files or parameter injection

### **Org Data Contamination**

- **Issue**: Wrong org data showing after switch
- **Solution**: Separate QueryClient instances + cache clearing

### **Database Context Issues**

- **Issue**: RLS not working or wrong org context
- **Solution**: Verify `_fn_set_app_context()` is called correctly

---

## **NEXT STEPS & PRIORITIES**

### **Immediate (Current Sprint)**

1. Complete Clerk authentication migration
2. Implement required PostgreSQL functions for Clerk integration
3. Update `_fn_set_app_context()` for Clerk ID support
4. Test end-to-end authentication flow

### **Short Term**

1. Implement webhook sync for real-time updates
2. Add comprehensive error handling
3. Performance optimization and monitoring
4. User onboarding and organization management UI

### **Long Term**

1. Advanced reporting and analytics
2. Market integration (eBay, Facebook, etc.)
3. Mobile application
4. Enterprise features and scaling

---

## **REFERENCE DOCUMENTS**

- `authentication-analysis-and-recommendations.md` - Detailed auth strategy
- `clerk-implementation-plan.md` - Step-by-step implementation guide
- `landing-page-requirements.md` - Marketing and user acquisition
- `db/schema.sql` - Complete database schema
- `db/functions/` - All PostgreSQL functions

---

**Last Updated**: January 2025  
**Current Focus**: Clerk authentication migration  
**Team Context**: Solo development with AI assistance
